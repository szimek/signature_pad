{
  "version": 3,
  "sources": ["../src/point.ts", "../src/bezier.ts", "../src/signature_event_target.ts", "../src/throttle.ts", "../src/signature_pad.ts", "<stdin>"],
  "sourcesContent": ["// Interface for point data structure used e.g. in SignaturePad#fromData method\nexport interface BasicPoint {\n  x: number;\n  y: number;\n  pressure: number;\n  time: number;\n}\n\nexport class Point implements BasicPoint {\n  public x: number;\n  public y: number;\n  public pressure: number;\n  public time: number;\n\n  constructor(x: number, y: number, pressure?: number, time?: number) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(`Point is invalid: (${x}, ${y})`);\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n\n  public distanceTo(start: BasicPoint): number {\n    return Math.sqrt(\n      Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2),\n    );\n  }\n\n  public equals(other: BasicPoint): boolean {\n    return (\n      this.x === other.x &&\n      this.y === other.y &&\n      this.pressure === other.pressure &&\n      this.time === other.time\n    );\n  }\n\n  public velocityFrom(start: BasicPoint): number {\n    return this.time !== start.time\n      ? this.distanceTo(start) / (this.time - start.time)\n      : 0;\n  }\n}\n", "import { BasicPoint, Point } from './point';\n\nexport class Bezier {\n  public static fromPoints(\n    points: Point[],\n    widths: { start: number; end: number },\n  ): Bezier {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n\n    return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n\n  private static calculateControlPoints(\n    s1: BasicPoint,\n    s2: BasicPoint,\n    s3: BasicPoint,\n  ): {\n    c1: BasicPoint;\n    c2: BasicPoint;\n  } {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n\n    const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n    const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n\n    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n    const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty),\n    };\n  }\n\n  constructor(\n    public startPoint: Point,\n    public control2: BasicPoint,\n    public control1: BasicPoint,\n    public endPoint: Point,\n    public startWidth: number,\n    public endWidth: number,\n  ) {}\n\n  // Returns approximated length. Code taken from https://www.lemoda.net/maths/bezier-length/index.html.\n  public length(): number {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(\n        t,\n        this.startPoint.x,\n        this.control1.x,\n        this.control2.x,\n        this.endPoint.x,\n      );\n      const cy = this.point(\n        t,\n        this.startPoint.y,\n        this.control1.y,\n        this.control2.y,\n        this.endPoint.y,\n      );\n\n      if (i > 0) {\n        const xdiff = cx - (px as number);\n        const ydiff = cy - (py as number);\n\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n\n      px = cx;\n      py = cy;\n    }\n\n    return length;\n  }\n\n  // Calculate parametric value of x or y given t and the four point coordinates of a cubic bezier curve.\n  private point(\n    t: number,\n    start: number,\n    c1: number,\n    c2: number,\n    end: number,\n  ): number {\n    // prettier-ignore\n    return (       start * (1.0 - t) * (1.0 - t)  * (1.0 - t))\n         + (3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t)\n         + (3.0 *  c2    * (1.0 - t) * t          * t)\n         + (       end   * t         * t          * t);\n  }\n}\n", "export class SignatureEventTarget {\n  /* tslint:disable: variable-name */\n  private _et: EventTarget;\n  /* tslint:enable: variable-name */\n\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch {\n      // Using document as EventTarget to support iOS 13 and older.\n      // Because EventTarget constructor just exists at iOS 14 and later.\n      this._et = document;\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    this._et.addEventListener(type, listener, options);\n  }\n\n  dispatchEvent(event: Event): boolean {\n    return this._et.dispatchEvent(event);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    this._et.removeEventListener(type, callback, options);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias */\n// Slightly simplified version of http://stackoverflow.com/a/27078401/815507\n\nexport function throttle(\n  fn: (...args: any[]) => any,\n  wait = 250,\n): (this: any, ...args: any[]) => any {\n  let previous = 0;\n  let timeout: number | null = null;\n  let result: any;\n  let storedContext: any;\n  let storedArgs: any[];\n\n  const later = (): void => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function wrapper(this: any, ...args: any[]): any {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n\n    storedContext = this;\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n", "/**\n * The main idea and some parts of the code (e.g. drawing variable width B\u00E9zier curve) are taken from:\n * http://corner.squareup.com/2012/07/smoother-signatures.html\n *\n * Implementation of interpolation using cubic B\u00E9zier curves is taken from:\n * https://web.archive.org/web/20160323213433/http://www.benknowscode.com/2012/09/path-interpolation-using-cubic-bezier_9742.html\n *\n * Algorithm for approximated length of a B\u00E9zier curve is taken from:\n * http://www.lemoda.net/maths/bezier-length/index.html\n */\n\nimport { Bezier } from './bezier';\nimport { BasicPoint, Point } from './point';\nimport { SignatureEventTarget } from './signature_event_target';\nimport { throttle } from './throttle';\n\nexport { BasicPoint } from './point';\n\nexport interface SignatureEvent {\n  event: MouseEvent | TouchEvent | PointerEvent;\n  type: string;\n  x: number;\n  y: number;\n  pressure: number;\n}\n\nexport interface FromDataOptions {\n  clear?: boolean;\n}\n\nexport interface ToSVGOptions {\n  includeBackgroundColor?: boolean;\n}\n\nexport interface PointGroupOptions {\n  dotSize: number;\n  minWidth: number;\n  maxWidth: number;\n  penColor: string;\n  highlightColor: string;\n  highlightSize: number;\n  velocityFilterWeight: number;\n  /**\n   * This is the globalCompositeOperation for the line.\n   * *default: 'source-over'*\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   */\n  compositeOperation: GlobalCompositeOperation;\n}\n\nexport interface Options extends Partial<PointGroupOptions> {\n  minDistance?: number;\n  backgroundColor?: string;\n  throttle?: number;\n  canvasContextOptions?: CanvasRenderingContext2DSettings;\n}\n\nexport interface PointGroup extends PointGroupOptions {\n  points: BasicPoint[];\n}\n\nexport default class SignaturePad extends SignatureEventTarget {\n  // Public stuff\n  public dotSize: number;\n  public minWidth: number;\n  public maxWidth: number;\n  public penColor: string;\n  public highlightColor: string;\n  public highlightSize: number;\n  public minDistance: number;\n  public velocityFilterWeight: number;\n  public compositeOperation: GlobalCompositeOperation;\n  public backgroundColor: string;\n  public throttle: number;\n  public canvasContextOptions: CanvasRenderingContext2DSettings;\n\n  // Private stuff\n  /* tslint:disable: variable-name */\n  private _ctx: CanvasRenderingContext2D;\n  private _drawingStroke = false;\n  private _isEmpty = true;\n  private _lastPoints: Point[] = []; // Stores up to 4 most recent points; used to generate a new curve\n  private _data: PointGroup[] = []; // Stores all points in groups (one group per line or dot)\n  private _lastVelocity = 0;\n  private _lastWidth = 0;\n  private _strokeMoveUpdate: (event: SignatureEvent) => void;\n  private _strokePointerId: number | undefined;\n  /* tslint:enable: variable-name */\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    options: Options = {},\n  ) {\n    super();\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n\n    // We need to handle 0 value, so use `??` instead of `||`\n    this.throttle = options.throttle ?? 16; // in milliseconds\n    this.minDistance = options.minDistance ?? 5; // in pixels\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || 'black';\n    this.highlightColor = options.highlightColor ?? '';\n    this.highlightSize = options.highlightSize ?? 1;\n    this.backgroundColor = options.backgroundColor ?? 'rgba(0,0,0,0)';\n    this.compositeOperation = options.compositeOperation ?? 'source-over';\n    this.canvasContextOptions = options.canvasContextOptions ?? {};\n\n    this._strokeMoveUpdate = this.throttle\n      ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n      : SignaturePad.prototype._strokeUpdate;\n\n    this._handleMouseDown = this._handleMouseDown.bind(this);\n    this._handleMouseMove = this._handleMouseMove.bind(this);\n    this._handleMouseUp = this._handleMouseUp.bind(this);\n    this._handleTouchStart = this._handleTouchStart.bind(this);\n    this._handleTouchMove = this._handleTouchMove.bind(this);\n    this._handleTouchEnd = this._handleTouchEnd.bind(this);\n    this._handlePointerDown = this._handlePointerDown.bind(this);\n    this._handlePointerMove = this._handlePointerMove.bind(this);\n    this._handlePointerUp = this._handlePointerUp.bind(this);\n\n    this._ctx = canvas.getContext(\n      '2d',\n      this.canvasContextOptions,\n    ) as CanvasRenderingContext2D;\n\n    this.clear();\n\n    // Enable mouse and touch event handlers\n    this.on();\n  }\n\n  public clear(): void {\n    const { _ctx: ctx, canvas } = this;\n\n    // Clear canvas using background color\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n    this._strokePointerId = undefined;\n  }\n\n  public fromDataURL(\n    dataUrl: string,\n    options: {\n      ratio?: number;\n      width?: number;\n      height?: number;\n      xOffset?: number;\n      yOffset?: number;\n    } = {},\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n\n      this._reset(this._getPointGroupOptions());\n\n      image.onload = (): void => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = (error): void => {\n        reject(error);\n      };\n      image.crossOrigin = 'anonymous';\n      image.src = dataUrl;\n\n      this._isEmpty = false;\n    });\n  }\n\n  public toDataURL(\n    type: 'image/svg+xml',\n    encoderOptions?: ToSVGOptions,\n  ): string;\n  public toDataURL(type?: string, encoderOptions?: number): string;\n  public toDataURL(\n    type = 'image/png',\n    encoderOptions?: number | ToSVGOptions | undefined,\n  ): string {\n    switch (type) {\n      case 'image/svg+xml':\n        if (typeof encoderOptions !== 'object') {\n          encoderOptions = undefined;\n        }\n        return `data:image/svg+xml;base64,${btoa(\n          this.toSVG(encoderOptions as ToSVGOptions),\n        )}`;\n      default:\n        if (typeof encoderOptions !== 'number') {\n          encoderOptions = undefined;\n        }\n        return this.canvas.toDataURL(type, encoderOptions as number);\n    }\n  }\n\n  public on(): void {\n    // Disable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'none';\n    (\n      this.canvas.style as CSSStyleDeclaration & {\n        msTouchAction: string | null;\n      }\n    ).msTouchAction = 'none';\n    this.canvas.style.userSelect = 'none';\n\n    const isIOS =\n      /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n\n    // The \"Scribble\" feature of iOS intercepts point events. So that we can\n    // lose some of them when tapping rapidly. Use touch events for iOS\n    // platforms to prevent it. See\n    // https://developer.apple.com/forums/thread/664108 for more information.\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n\n      if ('ontouchstart' in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n\n  public off(): void {\n    // Enable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'auto';\n    (\n      this.canvas.style as CSSStyleDeclaration & {\n        msTouchAction: string | null;\n      }\n    ).msTouchAction = 'auto';\n    this.canvas.style.userSelect = 'auto';\n\n    this.canvas.removeEventListener('pointerdown', this._handlePointerDown);\n    this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n\n    this._removeMoveUpEventListeners();\n  }\n\n  private _getListenerFunctions() {\n    const canvasWindow =\n      window.document === this.canvas.ownerDocument\n        ? window\n        : (this.canvas.ownerDocument.defaultView ?? this.canvas.ownerDocument);\n\n    return {\n      addEventListener: canvasWindow.addEventListener.bind(\n        canvasWindow,\n      ) as typeof window.addEventListener,\n      removeEventListener: canvasWindow.removeEventListener.bind(\n        canvasWindow,\n      ) as typeof window.removeEventListener,\n    };\n  }\n\n  private _removeMoveUpEventListeners(): void {\n    const { removeEventListener } = this._getListenerFunctions();\n    removeEventListener('pointermove', this._handlePointerMove);\n    removeEventListener('pointerup', this._handlePointerUp);\n\n    removeEventListener('mousemove', this._handleMouseMove);\n    removeEventListener('mouseup', this._handleMouseUp);\n\n    removeEventListener('touchmove', this._handleTouchMove);\n    removeEventListener('touchend', this._handleTouchEnd);\n  }\n\n  public isEmpty(): boolean {\n    return this._isEmpty;\n  }\n\n  public fromData(\n    pointGroups: PointGroup[],\n    { clear = true }: FromDataOptions = {},\n  ): void {\n    if (clear) {\n      this.clear();\n    }\n\n    this._fromData(\n      pointGroups,\n      this._drawCurve.bind(this),\n      this._drawDot.bind(this),\n    );\n\n    this._data = this._data.concat(pointGroups);\n  }\n\n  public toData(): PointGroup[] {\n    return this._data;\n  }\n\n  private _isLeftButtonPressed(event: MouseEvent, only?: boolean): boolean {\n    if (only) {\n      return event.buttons === 1;\n    }\n\n    return (event.buttons & 1) === 1;\n  }\n  private _pointerEventToSignatureEvent(\n    event: MouseEvent | PointerEvent,\n  ): SignatureEvent {\n    return {\n      event: event,\n      type: event.type,\n      x: event.clientX,\n      y: event.clientY,\n      pressure: 'pressure' in event ? event.pressure : 0,\n    };\n  }\n\n  private _touchEventToSignatureEvent(event: TouchEvent): SignatureEvent {\n    const touch = event.changedTouches[0];\n    return {\n      event: event,\n      type: event.type,\n      x: touch.clientX,\n      y: touch.clientY,\n      pressure: touch.force,\n    };\n  }\n\n  // Event handlers\n  private _handleMouseDown(event: MouseEvent): void {\n    if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n      return;\n    }\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _handleMouseMove(event: MouseEvent): void {\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when not pressing primary button or pressing multiple buttons\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _handleMouseUp(event: MouseEvent): void {\n    if (this._isLeftButtonPressed(event)) {\n      return;\n    }\n\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _handleTouchStart(event: TouchEvent): void {\n    if (event.targetTouches.length !== 1 || this._drawingStroke) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this._strokeBegin(this._touchEventToSignatureEvent(event));\n  }\n\n  private _handleTouchMove(event: TouchEvent): void {\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    if (!this._drawingStroke) {\n      this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n  }\n\n  private _handleTouchEnd(event: TouchEvent): void {\n    if (event.targetTouches.length !== 0) {\n      return;\n    }\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this._strokeEnd(this._touchEventToSignatureEvent(event));\n  }\n\n  private _getPointerId(event: PointerEvent) {\n    // @ts-expect-error persistentDeviceId is not available yet but we want to use it when it is available\n    return event.persistentDeviceId || event.pointerId;\n  }\n\n  private _allowPointerId(\n    event: PointerEvent,\n    allowUndefined = false,\n  ): boolean {\n    if (typeof this._strokePointerId === 'undefined') {\n      return allowUndefined;\n    }\n\n    return this._getPointerId(event) === this._strokePointerId;\n  }\n\n  private _handlePointerDown(event: PointerEvent): void {\n    if (\n      this._drawingStroke ||\n      !this._isLeftButtonPressed(event) ||\n      !this._allowPointerId(event, true)\n    ) {\n      return;\n    }\n\n    this._strokePointerId = this._getPointerId(event);\n\n    event.preventDefault();\n\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _handlePointerMove(event: PointerEvent): void {\n    if (!this._allowPointerId(event)) {\n      return;\n    }\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when primary button not pressed or multiple buttons pressed\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _handlePointerUp(event: PointerEvent): void {\n    if (this._isLeftButtonPressed(event) || !this._allowPointerId(event)) {\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n\n  private _getPointGroupOptions(group?: PointGroup): PointGroupOptions {\n    return {\n      penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n      highlightColor:\n        group && 'highlightColor' in group\n          ? group.highlightColor\n          : this.highlightColor,\n      highlightSize:\n        group && 'highlightSize' in group\n          ? group.highlightSize\n          : this.highlightSize,\n      dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n      minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n      maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight:\n        group && 'velocityFilterWeight' in group\n          ? group.velocityFilterWeight\n          : this.velocityFilterWeight,\n      compositeOperation:\n        group && 'compositeOperation' in group\n          ? group.compositeOperation\n          : this.compositeOperation,\n    };\n  }\n\n  // Private methods\n  private _strokeBegin(event: SignatureEvent): void {\n    const cancelled = !this.dispatchEvent(\n      new CustomEvent('beginStroke', { detail: event, cancelable: true }),\n    );\n    if (cancelled) {\n      return;\n    }\n\n    const { addEventListener } = this._getListenerFunctions();\n    switch (event.event.type) {\n      case 'mousedown':\n        addEventListener('mousemove', this._handleMouseMove, {\n          passive: false,\n        });\n        addEventListener('mouseup', this._handleMouseUp, { passive: false });\n        break;\n      case 'touchstart':\n        addEventListener('touchmove', this._handleTouchMove, {\n          passive: false,\n        });\n        addEventListener('touchend', this._handleTouchEnd, { passive: false });\n        break;\n      case 'pointerdown':\n        addEventListener('pointermove', this._handlePointerMove, {\n          passive: false,\n        });\n        addEventListener('pointerup', this._handlePointerUp, {\n          passive: false,\n        });\n        break;\n      default:\n      // do nothing\n    }\n\n    this._drawingStroke = true;\n\n    const pointGroupOptions = this._getPointGroupOptions();\n\n    const newPointGroup: PointGroup = {\n      ...pointGroupOptions,\n      points: [],\n    };\n\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n\n  private _strokeUpdate(event: SignatureEvent): void {\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (this._data.length === 0) {\n      // This can happen if clear() was called while a signature is still in progress,\n      // or if there is a race condition between start/update events.\n      this._strokeBegin(event);\n      return;\n    }\n\n    this.dispatchEvent(\n      new CustomEvent('beforeUpdateStroke', { detail: event }),\n    );\n\n    const point = this._createPoint(event.x, event.y, event.pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint =\n      lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint\n      ? point.distanceTo(lastPoint) <= this.minDistance\n      : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n\n    // Skip this point if it's too close to the previous one\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure,\n      });\n\n      if (!lastPoint) {\n        if (\n          pointGroupOptions.highlightColor &&\n          pointGroupOptions.highlightSize\n        ) {\n          this._drawDot(point, pointGroupOptions, true);\n        }\n        this._drawDot(point, pointGroupOptions, false);\n      } else if (curve) {\n        if (\n          pointGroupOptions.highlightColor &&\n          pointGroupOptions.highlightSize\n        ) {\n          this._drawAll(\n            lastPoints,\n            pointGroupOptions,\n            this._drawCurve.bind(this),\n            true,\n          );\n          this._drawAll(\n            lastPoints,\n            pointGroupOptions,\n            this._drawCurve.bind(this),\n            false,\n          );\n        } else {\n          this._drawCurve(curve, pointGroupOptions, false);\n        }\n      }\n    }\n\n    this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n  }\n\n  private _strokeEnd(event: SignatureEvent, shouldUpdate = true): void {\n    this._removeMoveUpEventListeners();\n\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (shouldUpdate) {\n      this._strokeUpdate(event);\n    }\n\n    this._drawingStroke = false;\n    this._strokePointerId = undefined;\n    this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n  }\n\n  private _handlePointerEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('pointerdown', this._handlePointerDown, {\n      passive: false,\n    });\n  }\n\n  private _handleMouseEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('mousedown', this._handleMouseDown, {\n      passive: false,\n    });\n  }\n\n  private _handleTouchEvents(): void {\n    this.canvas.addEventListener('touchstart', this._handleTouchStart, {\n      passive: false,\n    });\n  }\n\n  // Called when a new line is started\n  private _reset(options: PointGroupOptions): void {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n    this._ctx.globalCompositeOperation = options.compositeOperation;\n  }\n\n  private _createPoint(x: number, y: number, pressure: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n\n    return new Point(\n      x - rect.left,\n      y - rect.top,\n      pressure,\n      new Date().getTime(),\n    );\n  }\n\n  // Add point to _lastPoints array and generate a new curve if there are enough points (i.e. 3)\n  private _addPoint(point: Point, options: PointGroupOptions): Bezier | null {\n    const { _lastPoints } = this;\n\n    _lastPoints.push(point);\n\n    if (_lastPoints.length > 2) {\n      // To reduce the initial lag make it work with 3 points\n      // by copying the first point to the beginning.\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n\n      // _points array will always have 4 points here.\n      const widths = this._calculateCurveWidths(\n        _lastPoints[1],\n        _lastPoints[2],\n        options,\n      );\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n\n      // Remove the first element from the list, so that there are no more than 4 points at any time.\n      _lastPoints.shift();\n\n      return curve;\n    }\n\n    return null;\n  }\n\n  private _calculateCurveWidths(\n    startPoint: Point,\n    endPoint: Point,\n    options: PointGroupOptions,\n  ): { start: number; end: number } {\n    const velocity =\n      options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n      (1 - options.velocityFilterWeight) * this._lastVelocity;\n\n    const newWidth = this._strokeWidth(velocity, options);\n\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth,\n    };\n\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n\n    return widths;\n  }\n\n  private _strokeWidth(velocity: number, options: PointGroupOptions): number {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n\n  private _drawCurveSegment(x: number, y: number, width: number): void {\n    const ctx = this._ctx;\n\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n\n  private _drawCurve(\n    curve: Bezier,\n    options: PointGroupOptions,\n    isHighlight: boolean,\n  ): void {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    // '2' is just an arbitrary number here. If only length is used, then\n    // there are gaps between curve segments :/\n    const drawSteps = Math.ceil(curve.length()) * 2;\n\n    ctx.beginPath();\n    ctx.fillStyle = isHighlight ? options.highlightColor : options.penColor;\n\n    for (let i = 0; i < drawSteps; i += 1) {\n      // Calculate the Bezier (x, y) coordinate for this step.\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n\n      const width = Math.min(\n        curve.startWidth + ttt * widthDelta,\n        options.maxWidth,\n      );\n      this._drawCurveSegment(\n        x,\n        y,\n        width + (isHighlight ? options.highlightSize * 2 : 0),\n      );\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private _drawDot(\n    point: BasicPoint,\n    options: PointGroupOptions,\n    isHighlight: boolean,\n  ): void {\n    const ctx = this._ctx;\n    const width =\n      options.dotSize > 0\n        ? options.dotSize\n        : (options.minWidth + options.maxWidth) / 2;\n\n    ctx.beginPath();\n    this._drawCurveSegment(\n      point.x,\n      point.y,\n      width + (isHighlight ? options.highlightSize * 2 : 0),\n    );\n    ctx.closePath();\n    ctx.fillStyle = isHighlight ? options.highlightColor : options.penColor;\n    ctx.fill();\n  }\n\n  private _fromData(\n    pointGroups: PointGroup[],\n    drawCurve: typeof this._drawCurve,\n    drawDot: typeof this._drawDot,\n  ): void {\n    for (const group of pointGroups) {\n      const { points } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n\n      if (points.length > 1) {\n        if (\n          pointGroupOptions.highlightColor &&\n          pointGroupOptions.highlightSize\n        ) {\n          this._drawAll(points, pointGroupOptions, drawCurve, true);\n        }\n        this._drawAll(points, pointGroupOptions, drawCurve, false);\n      } else {\n        this._reset(pointGroupOptions);\n        if (\n          pointGroupOptions.highlightColor &&\n          pointGroupOptions.highlightSize\n        ) {\n          drawDot(points[0], pointGroupOptions, true);\n        }\n        drawDot(points[0], pointGroupOptions, false);\n      }\n    }\n  }\n\n  private _drawAll(\n    points: BasicPoint[],\n    pointGroupOptions: PointGroupOptions,\n    drawCurve: typeof this._drawCurve,\n    isHighlight: boolean,\n  ): void {\n    for (let j = 0; j < points.length; j += 1) {\n      const basicPoint = points[j];\n      const point = new Point(\n        basicPoint.x,\n        basicPoint.y,\n        basicPoint.pressure,\n        basicPoint.time,\n      );\n\n      if (j === 0) {\n        this._reset(pointGroupOptions);\n      }\n\n      const curve = this._addPoint(point, pointGroupOptions);\n\n      if (curve) {\n        drawCurve(curve, pointGroupOptions, isHighlight);\n      }\n    }\n  }\n\n  public toSVG({ includeBackgroundColor = false }: ToSVGOptions = {}): string {\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n    svg.setAttribute('width', maxX.toString());\n    svg.setAttribute('height', maxY.toString());\n\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement('rect');\n      rect.setAttribute('width', '100%');\n      rect.setAttribute('height', '100%');\n      rect.setAttribute('fill', this.backgroundColor);\n\n      svg.appendChild(rect);\n    }\n\n    this._fromData(\n      pointGroups,\n\n      (curve, { penColor, highlightColor, highlightSize }, isHighlight) => {\n        const path = document.createElement('path');\n\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        if (\n          !isNaN(curve.control1.x) &&\n          !isNaN(curve.control1.y) &&\n          !isNaN(curve.control2.x) &&\n          !isNaN(curve.control2.y)\n        ) {\n          const attr =\n            `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(\n              3,\n            )} ` +\n            `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n            `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n            `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n          path.setAttribute('d', attr);\n          path.setAttribute(\n            'stroke-width',\n            (\n              (curve.endWidth + (isHighlight ? highlightSize * 2 : 0)) *\n              2.25\n            ).toFixed(3),\n          );\n          path.setAttribute('stroke', isHighlight ? highlightColor : penColor);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n\n          svg.appendChild(path);\n        }\n      },\n\n      (\n        point,\n        {\n          penColor,\n          highlightColor,\n          highlightSize,\n          dotSize,\n          minWidth,\n          maxWidth,\n        },\n        isHighlight,\n      ) => {\n        const circle = document.createElement('circle');\n        const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n        circle.setAttribute(\n          'r',\n          (size + (isHighlight ? highlightSize * 2 : 0)).toString(),\n        );\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', isHighlight ? highlightColor : penColor);\n\n        svg.appendChild(circle);\n      },\n    );\n\n    return svg.outerHTML;\n  }\n}\n", "module.exports = require(\"./src/signature_pad.ts\").default"],
  "mappings": "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",
  "names": ["Point", "init_point", "__esmMin", "x", "y", "pressure", "time", "start", "other", "Bezier", "init_bezier", "__esmMin", "init_point", "_Bezier", "startPoint", "control2", "control1", "endPoint", "startWidth", "endWidth", "points", "widths", "c2", "c3", "s1", "s2", "s3", "dx1", "dy1", "dx2", "dy2", "m1", "m2", "l1", "l2", "dxm", "dym", "k", "cm", "tx", "ty", "Point", "length", "px", "py", "i", "t", "cx", "cy", "xdiff", "ydiff", "start", "c1", "end", "SignatureEventTarget", "init_signature_event_target", "__esmMin", "type", "listener", "options", "event", "callback", "throttle", "fn", "wait", "previous", "timeout", "result", "storedContext", "storedArgs", "later", "args", "now", "remaining", "init_throttle", "__esmMin", "signature_pad_exports", "__export", "SignaturePad", "init_signature_pad", "__esmMin", "init_bezier", "init_point", "init_signature_event_target", "init_throttle", "_SignaturePad", "SignatureEventTarget", "canvas", "options", "throttle", "ctx", "dataUrl", "resolve", "reject", "image", "ratio", "width", "height", "xOffset", "yOffset", "error", "type", "encoderOptions", "isIOS", "canvasWindow", "removeEventListener", "pointGroups", "clear", "event", "only", "touch", "allowUndefined", "group", "addEventListener", "pointGroupOptions", "newPointGroup", "point", "lastPointGroup", "lastPoints", "lastPoint", "isLastPointTooClose", "curve", "shouldUpdate", "x", "y", "pressure", "rect", "Point", "_lastPoints", "widths", "Bezier", "startPoint", "endPoint", "velocity", "newWidth", "isHighlight", "widthDelta", "drawSteps", "i", "t", "tt", "ttt", "u", "uu", "uuu", "drawCurve", "drawDot", "points", "j", "basicPoint", "includeBackgroundColor", "minX", "minY", "maxX", "maxY", "svg", "penColor", "highlightColor", "highlightSize", "path", "attr", "dotSize", "minWidth", "maxWidth", "circle", "size"]
}
